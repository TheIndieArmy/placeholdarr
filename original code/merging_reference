# Comprehensive Code Audit: Current Implementation vs. Original Code

## handle_webhook Function

**Original Implementation**: The original code had separate webhook handlers in different services. `integrations.py` handled Radarr webhooks through `process_radarr_webhook()` while Chronicle handled Sonarr separately.

**Current Implementation**: We've implemented a unified `handle_webhook()` function that processes events from both Radarr and Sonarr based on payload structure.

**Key Differences**: The current implementation determines the source (Radarr vs Sonarr) by examining payload keys, then routes to appropriate handlers. This consolidates what was previously in separate services.

def handle_webhook(data, source_port=None):
    try:
        source = "unknown"
        
        if 'movie' in data:
            # This is from Radarr
            source = "Radarr"
            # Handle Radarr events...
        elif 'series' in data:
            # This is from Sonarr
            source = "Sonarr"
            # Handle Sonarr events...
        elif 'event' in data:
            # This is from Plex
            source = "Plex"
            # Handle Plex events...
    except Exception as e:
        logger.error(f"Webhook handling failed: {str(e)}")

## is_4k_request Function

**Original Implementation**: The original code determined 4K content differently in each service. Integrations used specific folder paths for 4K content, while Chronicle had its own detection mechanism.

**Current Implementation**: We've implemented a unified detection function that works across both movie and TV show webhooks.

**Key Differences**: The current approach checks both source port and file path to determine if content is 4K, providing more flexibility than the original implementations.

def is_4k_request(file_path, source_port=None):
    # Check port against 4K ports
    if source_port:
        if str(source_port) == str(settings.RADARR_4K_PORT) or str(source_port) == str(settings.SONARR_4K_PORT):
            return True
    
    # Check path for 4K indicators
    if file_path and settings.PATH_4K_IDENTIFIER and settings.PATH_4K_IDENTIFIER.lower() in file_path.lower():
        return True
        
    return False

## handle_movieadd Function

**Original Implementation**: In `integrations.py`, the `handle_radarr_added()` function processed new movie additions and created placeholders.

**Current Implementation**: Our `handle_movieadd()` function performs similar functionality but includes additional support for 4K detection.

**Key Differences**: The current function accepts an `is_4k` parameter to determine which library folder to use, whereas the original code used fixed paths.

def handle_movieadd(data, is_4k=False):
    try:
        movie = data.get('movie', {})
        title = movie.get('title', 'Unknown')
        year = movie.get('year')
        tmdb_id = movie.get('tmdbId')
        
        logger.info(f"New movie added: {title} ({year}) (TMDB: {tmdb_id})")
        
        # Use the correct movie folder based on quality
        movie_folder = settings.MOVIE_LIBRARY_4K_FOLDER if is_4k else settings.MOVIE_LIBRARY_FOLDER
        
        # Create placeholder
        file_path = place_dummy_file("movie", movie_folder, title, year, tmdb_id)
        
        # Schedule [Request] tag update
        schedule_movie_request_update(title, tmdb_id, is_4k)
        
        return {"status": "success"}
    except Exception as e:
        logger.error(f"Error creating movie placeholder: {str(e)}")
        return {"status": "error", "message": str(e)}

## handle_seriesadd Function

**Original Implementation**: Chronicle had a similar function to process new series additions and create placeholders for episodes.

**Current Implementation**: Our `handle_seriesadd()` function consolidates this functionality and adds 4K support.

**Key Differences**: Like `handle_movieadd()`, this function now accepts an `is_4k` parameter. It also more explicitly handles season and episode data from the webhook.

def handle_seriesadd(data, is_4k=False):
    try:
        series = data.get('series', {})
        title = series.get('title', 'Unknown')
        year = series.get('year')
        tvdb_id = series.get('tvdbId')
        
        logger.info(f"New series added: {title} (TVDB: {tvdb_id})")
        
        # Use the correct TV folder based on quality
        tv_folder = settings.TV_LIBRARY_4K_FOLDER if is_4k else settings.TV_LIBRARY_FOLDER
        
        # Get season information
        seasons = series.get('seasons', [])
        
        # Create placeholders for episodes
        for season in seasons:
            season_num = season.get('seasonNumber')
            episode_count = season.get('statistics', {}).get('episodeCount', 0)
            
            if season_num == 0 and not settings.INCLUDE_SPECIALS:
                continue  # Skip specials unless enabled
                
            for episode_num in range(1, episode_count + 1):
                place_dummy_file("episode", tv_folder, title, year, tvdb_id, season_num, episode_num)
        
        # Schedule [Request] tag update
        schedule_episode_request_update(tvdb_id, 1, 1, "Episode 1", is_4k)
        
        return {"status": "success"}
    except Exception as e:
        logger.error(f"Error creating series placeholder: {str(e)}")
        return {"status": "error", "message": str(e)}

## handle_movie_delete Function

**Original Implementation**: In `integrations.py`, the `handle_radarr_deleted()` function removed movie placeholders when movies were deleted.

**Current Implementation**: Our `handle_movie_delete()` function performs the same task but handles both standard and 4K libraries.

**Key Differences**: The current implementation checks both standard and 4K libraries for placeholders to delete, whereas the original only looked in a single library path.

def handle_movie_delete(data):
    try:
        movie = data.get('movie', {})
        title = movie.get('title', 'Unknown')
        folder_path = movie.get('folderPath', '')
        
        logger.info(f"Movie deleted from Radarr: {title}")
        
        # Find and delete placeholders from both standard and 4K libraries
        for is_4k in [False, True]:
            library_folder = settings.MOVIE_LIBRARY_4K_FOLDER if is_4k else settings.MOVIE_LIBRARY_FOLDER
            
            if not library_folder:
                continue
                
            # Find folders matching the movie title pattern
            possible_folders = []
            try:
                for folder in os.listdir(library_folder):
                    if folder.startswith(title) and "(dummy)" in folder:
                        possible_folders.append(folder)
            except Exception as e:
                logger.error(f"Error listing directory {library_folder}: {str(e)}")
            
            # Delete matching folders
            for folder in possible_folders:
                full_path = os.path.join(library_folder, folder)
                try:
                    shutil.rmtree(full_path)
                    logger.info(f"Deleted placeholder folder: {full_path}")
                except Exception as e:
                    logger.error(f"Failed to delete folder {full_path}: {str(e)}")
        
        return {"status": "success", "message": f"Processed movie deletion: {title}"}
    except Exception as e:
        logger.error(f"Error handling movie deletion: {str(e)}")
        return {"status": "error", "message": str(e)}

## handle_seriesdelete Function

**Original Implementation**: Chronicle had a function to remove series placeholders when shows were deleted from Sonarr.

**Current Implementation**: Our `handle_seriesdelete()` function now handles both standard and 4K libraries.

**Key Differences**: Similar to movie deletion, we now check multiple library paths rather than a single fixed path.

def handle_seriesdelete(data):
    try:
        series = data.get('series', {})
        title = series.get('title', 'Unknown')
        tvdb_id = series.get('tvdbId')
        year = series.get('year')
        
        logger.info(f"Series deleted from Sonarr: {title}")
        
        # Find and remove placeholder folders from both libraries
        for is_4k in [False, True]:
            library_folder = settings.TV_LIBRARY_4K_FOLDER if is_4k else settings.TV_LIBRARY_FOLDER
            
            if not library_folder:
                continue
                
            # Build the expected folder name
            folder_name = get_folder_name("episode", title, year, tvdb_id)
            full_path = os.path.join(library_folder, folder_name)
            
            # Delete the folder if it exists
            if os.path.exists(full_path):
                try:
                    shutil.rmtree(full_path)
                    logger.info(f"Deleted placeholder folder: {full_path}")
                except Exception as e:
                    logger.error(f"Failed to delete folder {full_path}: {str(e)}")
        
        return {"status": "success", "message": f"Processed series deletion: {title}"}
    except Exception as e:
        logger.error(f"Error handling series deletion: {str(e)}")
        return {"status": "error", "message": str(e)}

## place_dummy_file Function

**Original Implementation**: Both services had similar functions to create placeholder files, though with slightly different implementations.

**Current Implementation**: We've unified the implementation to work for both movies and TV episodes.

**Key Differences**: The current function handles both media types (movies and episodes) and uses hardlinking with timestamp updates for all placeholders.

def place_dummy_file(media_type, base_path, title, year=None, media_id=None, season=None, episode=None):
    try:
        if media_type == "movie":
            # Create movie folder
            folder_name = get_folder_name(media_type, title, year, media_id)
            folder_path = os.path.join(base_path, folder_name)
        else:
            # Create TV series folder and season subfolder
            series_folder_name = get_folder_name(media_type, title, year, media_id)
            season_folder_name = f"Season {season:02d}"
            folder_path = os.path.join(base_path, series_folder_name, season_folder_name)
        
        os.makedirs(folder_path, exist_ok=True)
        
        # Create the file name
        file_name = get_file_name(media_type, title, year, season, episode)
        file_path = os.path.join(folder_path, file_name)
        
        if os.path.exists(file_path):
            logger.info(f"Placeholder already exists: {file_path}")
            return file_path
            
        # Create the dummy file - use hard link with updated timestamp
        try:
            os.link(settings.DUMMY_FILE_PATH, file_path)
            
            # Update the file's timestamp to current time
            current_time = time.time()
            os.utime(file_path, (current_time, current_time))
            
            logger.info(f"Created placeholder file: {file_path}")
            return file_path
        except Exception as e:
            # Fall back to copy if hard link fails
            shutil.copy(settings.DUMMY_FILE_PATH, file_path)
            
            # Update timestamp
            current_time = time.time()
            os.utime(file_path, (current_time, current_time))
            
            logger.info(f"Created placeholder file (copied): {file_path}")
            return file_path
            
    except Exception as e:
        logger.error(f"Error creating placeholder: {str(e)}")
        raise

## get_folder_name Function

**Original Implementation**: Both services had functions to generate folder names according to different conventions.

**Current Implementation**: We've unified the naming convention to work for both media types.

**Key Differences**: The current function uses a consistent pattern for both movie and TV show folders.

def get_folder_name(media_type, title, year=None, media_id=None):
    title = sanitize_filename(title)
    
    if media_type == "movie":
        # Movie folder: "{Movie Title} ({Year}) {tmdb-999999}{edition-Dummy}"
        return f"{title} ({year}) {{tmdb-{media_id}}}{{edition-Dummy}}"
    else:
        # TV folder: "{Series Title} ({year}) {tvdb-999999} (dummy)"
        year_str = f" ({year})" if year else ""
        return f"{title}{year_str} {{tvdb-{media_id}}} (dummy)"

## get_file_name Function

**Original Implementation**: Similar to folder naming, both services had functions to generate file names.

**Current Implementation**: Unified function to handle both movies and TV episodes.

**Key Differences**: Consistent file extension (.mp4) and naming patterns for both media types.

def get_file_name(media_type, title, year=None, season=None, episode=None):
    title = sanitize_filename(title)
    
    if media_type == "movie":
        # Movie file: "{Movie Title} ({Year}).mp4"
        return f"{title} ({year}).mp4"
    else:
        # TV file: "{Series Title} - s01e01.mp4"
        return f"{title} - s{season:02d}e{episode:02d}.mp4"

## schedule_movie_request_update Function

**Original Implementation**: The original code scheduled updates to add [Request] tags to movie titles in Plex.

**Current Implementation**: Similar functionality but with explicit 4K support.

**Key Differences**: Now handles both standard and 4K Plex libraries based on the is_4k parameter.

def schedule_movie_request_update(title, tmdb_id, is_4k=False):
    try:
        def update_movie_title(attempts=3):
            try:
                # Find the movie in Plex
                rating_key = find_movie_by_tmdb_id(tmdb_id, is_4k)
                
                if not rating_key:
                    if attempts > 0:
                        # Try again in a few seconds
                        threading.Timer(5.0, lambda: update_movie_title(attempts - 1)).start()
                    return
                    
                # Update the movie title with [Request] tag
                update_title(rating_key, title, "[Request]")
                
            except Exception as e:
                logger.error(f"Failed to update movie title: {e}")
                if attempts > 0:
                    threading.Timer(5.0, lambda: update_movie_title(attempts - 1)).start()
        
        # Start the update process with a delay
        threading.Timer(10.0, update_movie_title).start()
        lib_type = "4K" if is_4k else "standard"
        logger.info(f"Scheduled [Request] tag for '{title}' in {lib_type} library")
        
    except Exception as e:
        logger.error(f"Failed to schedule movie title update: {e}")

## schedule_episode_request_update Function

**Original Implementation**: Chronicle had a similar function for TV episodes.

**Current Implementation**: Now includes 4K support like its movie counterpart.

**Key Differences**: Handles both standard and 4K libraries based on the is_4k parameter.

def schedule_episode_request_update(tvdb_id, season, episode, title, is_4k=False):
    try:
        def update_episode_title(attempts=3):
            try:
                # Find the episode in Plex
                rating_key = find_episode_by_tvdb_id(tvdb_id, season, episode, is_4k)
                
                if not rating_key:
                    if attempts > 0:
                        # Try again in a few seconds
                        threading.Timer(5.0, lambda: update_episode_title(attempts - 1)).start()
                    return
                    
                # Update the episode title with [Request] tag
                update_title(rating_key, title, "[Request]")
                
            except Exception as e:
                logger.error(f"Failed to update episode title: {e}")
                if attempts > 0:
                    threading.Timer(5.0, lambda: update_episode_title(attempts - 1)).start()
        
        # Start the update process with a delay
        threading.Timer(10.0, update_episode_title).start()
        lib_type = "4K" if is_4k else "standard"
        logger.info(f"Scheduled [Request] tag for S{season:02d}E{episode:02d} in {lib_type} library")
        
    except Exception as e:
        logger.error(f"Failed to schedule episode title update: {e}")

## handle_moviefiledelete Function

**Original Implementation**: The original code didn't appear to have a specific handler for movie file deletion events.

**Current Implementation**: We've added a handler for these events.

**Key Differences**: New functionality to handle file deletion events specifically.

def handle_moviefiledelete(data):
    try:
        movie_file = data.get('movieFile', {})
        path = movie_file.get('path', '')
        movie = data.get('movie', {})
        title = movie.get('title', 'Unknown')
        
        logger.info(f"Movie file deleted: {path} ({title})")
        
        # We might want to create a placeholder here in the future,
        # but for now we'll just log it
        
        return {"status": "success", "message": "Processed movie file deletion"}
    except Exception as e:
        logger.error(f"Error handling movie file deletion: {str(e)}")
        return {"status": "error", "message": str(e)}

## handle_episodefiledelete Function

**Original Implementation**: Chronicle may have had a similar function but implementation details differ.

**Current Implementation**: We've added a handler for episode file deletion events.

**Key Differences**: Similar to movie file deletion, this is new or significantly modified functionality.

def handle_episodefiledelete(data):
    try:
        episode_file = data.get('episodeFile', {})
        path = episode_file.get('path', '')
        series = data.get('series', {})
        title = series.get('title', 'Unknown')
        
        logger.info(f"Episode file deleted: {path} ({title})")
        
        # We might want to create a placeholder here in the future,
        # but for now we'll just log it
        
        return {"status": "success", "message": "Processed episode file deletion"}
    except Exception as e:
        logger.error(f"Error handling episode file deletion: {str(e)}")
        return {"status": "error", "message": str(e)}

## handle_playback Function

**Original Implementation**: The original services may not have had direct integration with Plex playback events.

**Current Implementation**: We've added a handler for Plex playback webhooks.

**Key Differences**: This appears to be newly added functionality to process Plex playback events.

def handle_playback(data):
    try:
        event = data.get('event', '')
        media = data.get('media', {})
        media_type = media.get('type', '')
        title = media.get('title', 'Unknown')
        
        logger.info(f"Plex {event} event for {media_type}: {title}")
        
        # Process playback event (e.g., mark watched status)
        # Currently just logging the event
        
        return {"status": "success", "message": f"Processed Plex {event} event"}
    except Exception as e:
        logger.error(f"Error handling Plex playback event: {str(e)}")
        return {"status": "error", "message": str(e)}

## extract_ids Function

**Original Implementation**: Both services had functions to extract media IDs from folder names.

**Current Implementation**: Unified function that handles both TMDB and TVDB IDs.

**Key Differences**: Now handles multiple ID types with a more robust regex pattern.

def extract_ids(folder_name):
    """Extract media IDs from folder name"""
    ids = {}
    
    # Extract TMDB ID: {tmdb-123456}
    tmdb_match = re.search(r'{tmdb-(\d+)}', folder_name)
    if tmdb_match:
        ids['tmdb'] = tmdb_match.group(1)
    
    # Extract TVDB ID: {tvdb-123456}
    tvdb_match = re.search(r'{tvdb-(\d+)}', folder_name)
    if tvdb_match:
        ids['tvdb'] = tvdb_match.group(1)
    
    return ids

## find_movie_by_tmdb_id Function

**Original Implementation**: The original code searched for movies in Plex by TMDB ID.

**Current Implementation**: Enhanced to support both standard and 4K libraries.

**Key Differences**: Now searches in the appropriate library based on the is_4k parameter.

def find_movie_by_tmdb_id(tmdb_id, is_4k=False):
    """Find a movie in Plex by TMDB ID"""
    try:
        # Get the correct section ID
        section_id = settings.PLEX_MOVIE_4K_SECTION if is_4k else settings.PLEX_MOVIE_SECTION
        if not section_id:
            return None
            
        # Search by GUID
        url = build_plex_url(f"/library/sections/{section_id}/all")
        params = {
            'type': '1',  # 1 = movie
            'includeMeta': '1',
            'includeGuids': '1'
        }
        headers = {'X-Plex-Token': settings.PLEX_TOKEN}
        
        response = requests.get(url, params=params, headers=headers)
        if response.status_code != 200:
            logger.error(f"Failed to search Plex: {response.status_code}")
            return None
            
        # Parse XML response
        root = ET.fromstring(response.text)
        for video in root.findall('.//Video'):
            for guid in video.findall('./Guid'):
                guid_id = guid.get('id', '')
                if f'tmdb://{tmdb_id}' in guid_id:
                    return video.get('ratingKey')
                    
        return None
    except Exception as e:
        logger.error(f"Error finding movie by TMDB ID: {e}")
        return None

## find_episode_by_tvdb_id Function

**Original Implementation**: Chronicle had a similar function for finding episodes.

**Current Implementation**: Enhanced with 4K support like its movie counterpart.

**Key Differences**: Now searches in the appropriate library based on the is_4k parameter.

def find_episode_by_tvdb_id(tvdb_id, season, episode, is_4k=False):
    """Find an episode in Plex by TVDB ID, season, and episode"""
    try:
        # Get the correct section ID
        section_id = settings.PLEX_TV_4K_SECTION if is_4k else settings.PLEX_TV_SECTION
        if not section_id:
            return None
            
        logger.debug(f"Searching for episode with TVDB ID {tvdb_id}, S{season}E{episode} in {'4K' if is_4k else 'standard'} library (section {section_id})")
            
        # First find the series by TVDB ID
        url = build_plex_url(f"/library/sections/{section_id}/all")
        params = {
            'type': '2',  # 2 = TV show
            'includeMeta': '1',
            'includeGuids': '1'
        }
        headers = {'X-Plex-Token': settings.PLEX_TOKEN}
        
        response = requests.get(url, params=params, headers=headers)
        if response.status_code != 200:
            logger.error(f"Failed to search Plex: {response.status_code}")
            return None
            
        # Find the series first
        series_key = None
        root = ET.fromstring(response.text)
        for show in root.findall('.//Directory'):
            for guid in show.findall('./Guid'):
                guid_id = guid.get('id', '')
                if f'tvdb://{tvdb_id}' in guid_id:
                    series_key = show.get('ratingKey')
                    break
            if series_key:
                break
                
        if not series_key:
            logger.debug(f"Series with TVDB ID {tvdb_id} not found")
            return None
            
        # Now find the specific episode
        episode_url = build_plex_url(f"/library/metadata/{series_key}/allLeaves")
        episode_response = requests.get(episode_url, headers=headers)
        if episode_response.status_code != 200:
            logger.error(f"Failed to get episodes: {episode_response.status_code}")
            return None
            
        episode_root = ET.fromstring(episode_response.text)
        for ep in episode_root.findall('.//Video'):
            if int(ep.get('parentIndex', 0)) == season and int(ep.get('index', 0)) == episode:
                return ep.get('ratingKey')
                
        logger.debug(f"Episode S{season}E{episode} not found for series {series_key}")
        return None
    except Exception as e:
        logger.error(f"Error finding episode: {e}")
        return None

## update_title Function

**Original Implementation**: Both services had functions to update titles in Plex.

**Current Implementation**: Unified function to update any item title regardless of media type.

**Key Differences**: More generic implementation that works for both movies and TV episodes.

def update_title(rating_key, title, tag='[Request]'):
    """Update a title with a tag in Plex"""
    try:
        if not rating_key:
            return False
            
        # Build the API URL
        url = build_plex_url(f"/library/metadata/{rating_key}")
        
        # Check if title already has the tag
        if tag in title:
            return True
            
        # Add the tag to the title
        new_title = f"{title} {tag}"
        
        # Make the API call
        headers = {
            'X-Plex-Token': settings.PLEX_TOKEN,
            'Content-Type': 'application/json'
        }
        params = {
            'type': '1',
            'includeExternalMedia': '1',
            'title.value': new_title,
            'title.locked': '1'
        }
        
        response = requests.put(url, headers=headers, params=params)
        response.raise_for_status()
        
        logger.info(f"Updated title in Plex: '{title}' -> '{new_title}'")
        return True
    except Exception as e:
        logger.error(f"Failed to update title: {str(e)}")
        return False

## get_section_id Function

**Original Implementation**: The original code may have had separate handling for section IDs.

**Current Implementation**: Helper function to get the appropriate library section ID based on media type and quality.

**Key Differences**: Unified approach to getting section IDs for any media type and quality.

def get_section_id(media_type, is_4k=False):
    """Get the appropriate Plex library section ID"""
    if media_type == 'movie':
        return settings.PLEX_MOVIE_4K_SECTION if is_4k else settings.PLEX_MOVIE_SECTION
    elif media_type in ['episode', 'show', 'season']:
        return settings.PLEX_TV_4K_SECTION if is_4k else settings.PLEX_TV_SECTION
    return None

## build_plex_url Function

**Original Implementation**: Helper function to build Plex API URLs.

**Current Implementation**: Similar functionality but with more robust handling of path components.

**Key Differences**: Enhanced error handling and path normalization.

def build_plex_url(path: str) -> str:
    """Build a complete Plex URL with proper path handling"""
    # Ensure base URL has no trailing slash
    base = settings.PLEX_URL.rstrip('/')
    
    # Ensure path starts with a slash but remove any trailing slash
    if not path.startswith('/'):
        path = '/' + path
    path = path.rstrip('/')
    
    # Construct URL
    url = f"{base}{path}"
    return url

## sanitize_filename Function

**Original Implementation**: Both services had functions to sanitize filenames.

**Current Implementation**: Unified function for filename sanitization.

**Key Differences**: More comprehensive character replacement and normalization.

def sanitize_filename(filename):
    """Sanitize a filename to remove invalid characters"""
    if not filename:
        return "Unknown"
        
    # Replace invalid characters with underscore
    invalid_chars = r'[<>:"/\\|?*]'
    sanitized = re.sub(invalid_chars, '_', filename)
    
    # Remove leading/trailing periods and spaces
    sanitized = sanitized.strip('. ')
    
    # Ensure the filename is not empty
    if not sanitized:
        return "Unknown"
        
    return sanitized

# This audit covers all the significant functions in our current implementation and how they compare to the original code in integrations.py and chronicle.py. The main focus has been on unifying the two separate services into a single cohesive system while maintaining their core functionality.